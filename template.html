<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="utf-8">

    <title>SANS Data Reduction with Python</title>

    <meta name="description" content="Summer Work Presentation">
    <meta name="author" content="Tina Wang">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal/css/reveal.css">
    <link rel="stylesheet" href="reveal/css/theme/night.css" id="theme">
    <link rel="stylesheet" href="css/style.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        if (window.location.search.match(/print-pdf/gi)) {
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'reveal/css/print/pdf.css';
            document.getElementsByTagName('head')[0].appendChild(link);
        }
    </script>

    <!--[if lt IE 9]>
    <script src="reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
    <div class="reveal">

        <header class="left" style="position: absolute;top: 50px; left: 100px; z-index:500;"></header>
        <header class="bottom" style="position: absolute; bottom: 50px; width: 100%; text-align: center;"></header>

        <div class="slides">
            <section data-state="headleft">
                <style>
                    .headleft header.left:after {
                        content: url(img/SNS_color_2.png);
                    }
                </style>
                <style>
                    .headleft header.bottom:after {
                        content: url(img/footer.png);
                    }
                </style>

                <h2>SANS Data Reduction with Python</h2>

                <h3>August 8, 2016</h3>

                <p>
                    Tina Wang
                </p>
                <p>
                    <a href="mailto:wangts@ornl.gov" target="_blank">wangts@ornl.gov</a>
                </p>
            </section>


            <section>
              <section>
                <h2>Introduction</h2>
                <ul>
                    <li>Mantid structure: C++ with Python bindings</li>
                    <li>However, modern Python packages for
                      scientific computing provide suitable alternatives
                      <ul>
                        <li>e.g.: Scipy</li>
                        <li>NumPy</li>
                        <li>matplotlib</li>
                        <li>...etc.</li>
                      </ul>
                    </li>
                    <li>Will be implemented in the new SANS data reduction
                      web interface
                      <ul>
                        <li>Python backend</li>
                      </ul>
                    </li>
                      <aside class="notes">
                        <li>
                          C++ w/ Python bindings best choice at the time
                        </li>
                         <li>Implemented in Python a few HFIR
                         SANS data reduction methods to compare/contrast them
                         with methods in Mantid.</li>
                         <ul>
                           <li>
                             Did not want to install Mantid on the web server
                           </li>
                         </ul>
              </aside>
              </section>
              <section>
                <h2>SANS</h2>
                <ul>
                    <li>Small Angle Neutron Scattering (SANS)
                      <ul>
                        <li>Technique for viewing the structure
                          of polymers and biological molecules (proteins, etc.)
                        </li>
                      </ul>
                    </li>
                    <table>
                    <tr>
                    <td align="center"><img src="img/sans.jpg"></td>
                    </tr>
                  </table>
                  <aside class="notes">
                    <li>
                      Very brief background about SANS
                    </li>
                  <li> Presentation mainly concerned with
                  HFIR SANS data.</li></aside>
              </section>
                <section>
                    <h2>Outline</h2>
                    <ul>
                        <li>HFIR SANS Parser (HFIR XML files)
                          <ul>
                            <li>XPath Data Search</li>
                            <li>xarray</li>
                            <li>Graphing Capabilities</li>
                          </ul>
                        </li>
                        <li>Beam Finder</li>
                        <li>Sensitivity Correction</li>
                        <li>Ansiotropic SANS Refinement
                          <ul>
                            <li>Sector Averaging</li>
                            <li>Double Gaussian Fitting</li>
                            <li>Numba</li>
                          </ul>
                        </li>
                    </ul>
                      <aside class ="notes">
                        <ul>
                          <li>
                            First, talk about parser.
                          </li>
                          <li>
                            Beam Finder, Sensitivity Correction
                          </li>
                          <li>
                            Anisotropic SANS Refinement: process and numba
                          </li>
                        </ul>
                      </aside>
                </section>
            </section>

            <section>
                <section>
                    <h2> Parser for HFIR SANS</h2>
                </section>
                <section data-markdown>
                    ###XML to JSON Conversion and Data Extraction
                    * ElementTree Library
                      * Processing XML
                    * Can Return:
                        * Python Dictionary
                        * JSON String
                        * JSON File
                </section>
                <section data-markdown data-notes="^Note:">
                    <script type="text/template">
                      ##Searching via XPath
                      * XPath: "a syntax for defining parts of an XML document"
                      (W3Schools)
                      * Can retrieve data values given tag names
                      * Examples
                        * "p" is the Parser object

                      ```c
                      p = Parser("HFIR/.../xml_file.xml")

                      pixel_size_x = p.xpath_get("/SPICErack/Header/x_mm_per_pixel/#text")

                      pixel_size_y = p.xpath_get("/SPICErack/Header/y_mm_per_pixel/#text")

                      detector_data = np.array(p.xpath_get("/SPICErack/Data/Detector/data"))

                      # returns 2d array of detector data
                      ```


                        Note: XPath can easily search through the XML file and
                        "grab" the value in the desired data field
                    </script>
                </section>

                <section data-markdown data-notes="^Note:">
                  <!--  Insert Image-->

                  <script type="text/template">
                    ##xarray

                    * Formerly xray, compatible with pandas
                    * "N-D labeled arrays and datasets in Python"
                    * Used to keep x and y axes with data

                    ```c
                    import xarray as xr

                    detector_data = xr.DataArray(detector_data,
                                                coords=[x_axis_units, y_axis_units],
                                                dims=['x', 'y'])

                    detector_data.plot()
                  ```



                    ![alt text](img/plot.png)

                    Note: xarray makes it easy for datasets to be included with
                    axes corrected for units (pixels to milimeters)
                  </script>
                </section>
                <section>
                  <h2>xarray continued</h2>
                  <!-- Insert image -->
                  <ul>
                    <li>More code examples</li>
                    <li>Simple task to copy axes</li>
                  </ul>
                   <pre><code data-trim>
# (0,0) away from the beam center
data.plot()

data.x.values = beam_center.x.values
data.y.values = beam_center.y.values

# (0,0) at the beam center
data.plot()
                    </code></pre>
                    <img src="img/figure_1.png">
                    <img src="img/figure_2.png">
                    <aside class="notes">
                      It's also easy to take corrected axes and insert them onto
                      an uncorrected data set.
                      <li>
                        Graphs here show dataset before and after taking corrected
                        axis from the beam center.
                      </li>
                    </aside>
                </section>
                <section>
                    <h2>Background Subtraction</h2>
                    <ul>
                        <li>Subtracts out background data
                        for more accurate calculations</li>
                        <li>Very simple in Python:
                          <ul>
                            <li>subtracted_data = data - backgrd_data </li>
                          </ul>
                        </li>
                    </ul>
                </section>
                <section>
                    <h2>Translation</h2>
                    <ul>
                        <li>Translates center to correct location</li>
                        <li>Converts from pixels to mm</li>
                        <li>Found at
                          "/SPICErack/Motor_Positions/detector_trans/#text"</li>
                    </ul>
                    <aside class="notes">
                      Must translate the x-axis by the amount specified
                      in "detector_trans" in order to correct axes,
                      otherwise, data will be shifted by the translation.
                    </aside>
                </section>
                <section>
                    <h2>Graphing Capabilities</h2>
                    <aside class="notes">Plotly and matplotlib can graph radial
                    profile, data, and beam center.</aside>
                    <ul>
                        <li> Plotly Offline:
                          Integrates with web integrator
                        <ul>
                          <li>
                            Can be saved in a file or as a div
                               to display in a web page
                          </li>
                        </ul></li>
                        <li>matplotlib: Python scientific
                          graphing library</li>
                    </ul>

                      <img src = "img/radial_profile.PNG">
                      <img src = "img/subtracted.png">
                      <aside class="notes"> <ul>
                      <li>First integrates to get radial profile via the web
                        integrator. </li>
                        <li>
                          Plotly graph can be save as a div or as an html file
                        </li>

                      </aside>
                </section>

            <section>
                <h2>Process Outline</h2>
                <ul>
                  <li>Translate according to
                    "/SPICErack/Motor_Positions/detector_trans/#text"</li>
                  <li>Find ROI</li>
                  <li>Beam Center
                    <ul>
                      <li>ndimage</li>
                      <li>2D Gaussian fit</li>
                    </ul>
                  </li>
                  <li>Adjust axes</li>
                  <li>Create xarray DataArray</li>
                  <li>Plot 1D

                  </li>
                </ul>
                <aside class="notes">
                  <ul>
                    <li>Integrated in the web data reduction</li>
                    <li>Will give users overview of raw intensity</li>
                  </ul>
                </aside>
            </section>
          </section>

        <section>
            <section>
                <h2>Beam Finder</h2>
                <ul>
                  <li>Problem: Mantid gives different beam center than SPICE
                    <ul>
                      <li>SPICE is the LabVIEW-based data acquisition system</li>
                    </ul>
                  </li>
                </ul>
                  <table>
                  <tr>
                    <td align="center"><img src="img/spice.png"></td>
                    <td align="center"><img src="img/mantid.PNG"></td>
                  </tr>
                </table>
                <aside class="notes">
                  BioSANS scientists noticed that Mantid and SPICE were
                  producing different results for the center of mass
                </aside>
            </section>
                <section>
                    <h2>Method 1: Scipy.ndimage</h2>
                    <ul>
                        <li>scipy.ndimage.measurements.center_of_mass</li>
                        <li>Unexpected results</li>
                    </ul>

                    <img src = "img/wrong_center.png">
                    <aside class="notes">
                      We first tried the default scipy method for finding the
                      center of mass. Unexpected results
                    </aside>
                </section>
                <section>
                    <h2>Method 2: Center of Mass formula</h2>
                    <p>$$\vec{p} =  \frac{\sum\nolimits_{i} \sum\nolimits_{j} I_{ij}
                      \vec {d_{ij}}}{\sum\nolimits_{i} \sum\nolimits_{j} I_{ij}}$$
                    </p>
                    <ul>
                      <li>Mantid method</li>
                      <li>Starts at the edge of the detector,
                        and would loop until it was close to the correct point</li>
                        <li>Very similar results to ndimage</li>
                        <li>Unexpected results</li>
                    </ul>
                    <aside class="notes">
                      Mantid method. Delivered very similar results to ndimage's
                      center of mass function. Looped until two points were less
                      than 0.25 pixels away.
                    </aside>
                </section>
                <section>
                    <h2>Method 3: Absolute Maximum</h2>
                    <ul>
                      <li>Found absolute maximum point</li>
                      <li>Not always the same point as the center</li>
                    </ul>

                    <img src = "img/maximum_com.png">
                    <aside class="notes">
                      Absolute maximum location not the same as center of mass
                      in most files.
                    </aside>
                </section>
                <section>
                    <h2>Method 4: 2D Gaussian Fit</h2>
                    <ul>
                      <li>Found point close to actual beam center
                        via modified ndimage</li>
                      <li>Used point for an initial guess for a 2D Gaussian</li>
                      <li>Center of Gaussian: beam center</li>
                    </ul>

                    <img src = "img/right_center.png">
                    <aside class="notes">
                      <ul>
                        <li>
                          Modified ndimage took in acoount only the highest points
                        </li>
                        <li>
                          Used those points for an initial guess for the 2d
                          Gaussian
                        </li>
                      </ul>
                    </aside>
                </section>

        </section>


            <section>
                <section>
                    <h2>Sensitivity Correction</h2>
                    <ul>
                      <li>Problem: We saw a pattern of
                        vertical lines on some graphs.</li>
                      <li> Problem: Mantid finds the center before sensitivity
                      correction.
                    </li>
                    </ul>

                    <img src="img/vertical_pattern.png">
                    <aside class="notes">Since we have interleaved tubes,
                      and the back tubes get less neutrons than the front tubes,
                      the correction must be applied before center finding
                      <ul>
                        <li>According to scientists, this can be improved upon.</li>
                      </ul>
                    </aside>
                </section>
                  <section>
                        <h2>Compare and Contrast</h2>
                        <img src="img/vertical_pattern.png">
                        <img src="img/corrected.png">
                        <aside class="notes">Image to the right much smoother
                        and lacks the vertical pattern seen in the image on
                      the left. Defined center</aside>
                    </section>
                    <section>
                          <h2>Compare and Contrast</h2>
                          <img src="img/vertical_1d.png">
                          <img src="img/corrected_1d.png">
                          <aside class="notes">
                            <ul>
                              <li>
                                Point out smoother curve
                              </li>
                              <li>
                                Less noisy
                              </li>
                            </ul>
                          </aside>
                      </section>
                </section>


            <section>
                <section>
                    <h2>Anisotropic SANS Refinement</h2>
                    <ul>
                      <li>
                        Scientists needed to find the wedge angles automatically
                      </li>
                    </ul>
                    <img src="img/anisotropy.png">
                    <aside class="notes">

                    </aside>
                  </section>
                    <section>
                        <h2>Method</h2>
                        <ul>
                            <li>Sector average (NumPy) time:
                              <ul>
                                <li>1st run: 0.180018 seconds</li>
                                <li> 2nd: 0.029003 s</li>
                                <li> 3rd: 0.030003 s</li>
                              </ul>
                            </li>
                            <li>Wedge Finding:
                            <ul>
                              <li>Gaussian blur to smooth out noise</li>
                              <li> OpenCV: MinMaxLoc function</li>
                            </ul>
                          </li>
                        </ul>
                        <img src="img/sector_averages.png">
                        <!-- Label axes or talk about them in the presentation-->
                    </section>
                    <section>
                        <h2>Finding angles</h2>
                        <ul>
                            <li>Take y-coordinate of maximum and draw line</li>
                            <li>Gaussian Fit
                            <ul>
                              <li>Two Gaussians to find angles</li>
                              <li>Angles always around 180 degrees apart</li>
                              <li>Start at first dip and
                                add 360 to estimate location of angles</li>
                            </ul>
                            </li>
                        </ul>

                        <aside class ="notes">Took a spline of the data on
                        that line, and then fit the first Gaussian based on
                        where dip is.
                        <li>
                          Fit second Gaussian at first gaussian + 180
                        </li>
                      </aside>

                        <img src="img/double_gaussian.png">
                        <img src="img/double_cross.png">
                    </section>
                    <section data-markdown data-notes="^Note:">
                        <script type="text/template">
                              ##Numba
                              * A simple way to improve speed on "for" loops
                              and purely computational functions

                              ```c
                              from numba import jit

                              @jit
                              def get_center_of_mass(d):
                              ```
                              * Numba Test Runs with Random 3D Data (similar to
                              EQ SANS Data):
                                * NumPy runs at similar speed
                                * First @jit run is slower due to compiling
                                machine code
                                * Small size of HFIR Data inhibits large speed
                                improvement
                                  * General improvement between 25-30%
                              * Random z-values between 0 and 100:


                                ```c
                                14:51 $ python test_numba.py
                                Time non jit:      1.654 sec
                                Time non jit:      1.489 sec
                                Time jit:      5.046 sec
                                Time jit:      0.005 sec
                                Time jit:      0.005 sec
                                Time jit:      0.005 sec
                                Time jit:      0.005 sec
                                ```


                                Note: Numba increases speed of for loops. Didn't
                                work well here because data is only 192x256, but
                                should be more effective with EQ-SANS data.
                        </script>

                      </section>
                      <section data-markdown>
                          <script type="text/template">
                                ##Numba con't.
                                * More Tests
                                * Random EQ-SANS-like data
                                  * Random 3D data: z-values are from 0-1000:


                                ```c
                                14:59 $ python test_numba.py
                                Time non jit:     11.345 sec
                                Time non jit:     11.333 sec
                                Time jit:     52.778 sec
                                Time jit:      0.050 sec
                                Time jit:      0.049 sec
                                Time jit:      0.050 sec
                                Time jit:      0.050 sec
                                ```
                          </script>
                        </section>
                        <section>
                          <h2>Summary</h2>
                          <ul>
                            <li>XML to Python Dictionary/JSON Parser
                              <ul>
                                <li>xarray</li>
                              </ul>
                            </li>
                            <li>Beam finding methods
                              <ul>
                                <li>Scipy</li>
                                <li>Absolute maximum</li>
                                <li>2D Gaussian</li>
                              </ul>
                            </li>
                            <li>Sensitivity Correction</li>
                            <li>Anisotropic SANS refinement
                              <ul>
                                <li>Angle finding</li>
                                <li>Numba</li>
                              </ul>
                            </li>
                          </ul>

                        </section>
                </section>


            <section>
              <h2> Special Thanks </h2>
              <ul>
                <li class="fragment">Ricardo Leal</li>
                <li class="fragment">Thomas Proffen</li>
              </ul>
              <aside class="notes">
                <li>
                  Dr. Proffen for giving me the opportunity to speak today
                </li>
              </aside>
            </section>

            <section>
              <h2>Questions?</h2>
              </section>
        </div>
    </div>

    <script src="reveal/lib/js/head.min.js"></script>
    <script src="reveal/js/reveal.js"></script>

    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,
            theme: Reveal.getQueryHash().theme,
            transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
            dependencies: [
                // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
                {
                    src: 'reveal/lib/js/classList.js',
                    condition: function() {
                        return !document.body.classList;
                    }
                },

                // Interpret Markdown in <section> elements
                {
                    src: 'reveal/plugin/markdown/marked.js',
                    condition: function() {
                        return !!document.querySelector('[data-markdown]');
                    }
                }, {
                    src: 'reveal/plugin/markdown/markdown.js',
                    condition: function() {
                        return !!document.querySelector('[data-markdown]');
                    }
                },

                // Syntax highlight for <code> elements
                {
                    src: 'reveal/plugin/highlight/highlight.js',
                    async: true,
                    callback: function() {
                        hljs.initHighlightingOnLoad();
                    }
                },

                // Zoom in and out with Alt+click
                {
                    src: 'reveal/plugin/zoom-js/zoom.js',
                    async: true
                },

                // Speaker notes
                {
                    src: 'reveal/plugin/notes/notes.js',
                    async: true
                },

                // MathJax
                {
                    src: 'reveal/plugin/math/math.js',
                    async: true
                }
            ]
        });

    </script>
</body>

</html>
